// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum AccountType {
  SOLO
  BAND
}

enum Visibility {
  PRIVATE
  UNLISTED
  PUBLIC
}

enum PracticeCategory {
  WARMUP
  CHORDS
  SCALES
  SONGS
  THEORY
  EAR_TRAINING
  COOL_DOWN
}

enum WorkspaceType {
  PERSONAL
  BAND
}

enum WorkspaceRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

enum PracticeTargetType {
  SONG
  NOTE
  DRILL
  BLOCK
  CUSTOM
}

enum FocusMetricType {
  BPM
  ACCURACY
  REPS
  NOTES
  NONE
}

enum FocusDifficulty {
  EASY
  MEDIUM
  HARD
}

enum AssetStatus {
  PENDING_UPLOAD
  UPLOADED
  VERIFIED
  FAILED
}

enum ExportJobStatus {
  QUEUED
  RUNNING
  DONE
  FAILED
}

enum ExportFormat {
  WAV
  MP3
  MP4
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  email       String      @unique
  password    String
  name        String
  accountType AccountType @default(SOLO)
  avatar      String?

  // Collaboration
  memberships WorkspaceMember[]

  // Legacy ownership (you said you’re keeping this for now)
  songs         Song[]
  practicePlans PracticePlan[]

  // ✅ Back-relations for Note attribution (STOP Prisma from auto-adding junk)
  notesCreated Note[] @relation("NoteCreatedBy")
  notesUpdated Note[] @relation("NoteUpdatedBy")
}

model Song {
  id         Int        @id @default(autoincrement())
  title      String
  artist     String?
  ownerId    Int
  owner      User       @relation(fields: [ownerId], references: [id])
  visibility Visibility @default(PRIVATE)

  tempo      Int?
  key        String?
  capo       Int?
  timeSigTop Int?
  timeSigBot Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tabs Tab[]
  tags String[] @default([])

  // Optional: move songs into workspaces later; this lets you start now without breaking legacy
  workspaceId String?
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([workspaceId])
}

model Tab {
  id     Int  @id @default(autoincrement())
  songId Int
  song   Song @relation(fields: [songId], references: [id])

  title      String // e.g. "Acoustic version"
  tuning     String // "EADGBE"
  tempo      Int?
  timeSigTop Int?
  timeSigBot Int?
  capo       Int?   @default(0)

  currentRev Int?
  revisions  TabRevision[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([songId])
}

model TabRevision {
  id        Int      @id @default(autoincrement())
  tabId     Int
  tab       Tab      @relation(fields: [tabId], references: [id])
  number    Int
  message   String?
  score     Json
  createdBy Int
  createdAt DateTime @default(now())

  @@unique([tabId, number])
  @@index([tabId])
}

model PracticePlan {
  id          Int            @id @default(autoincrement())
  name        String
  description String?
  ownerId     Int
  owner       User           @relation(fields: [ownerId], references: [id])
  items       PracticeItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Link back to a source note (optional)
  sourceNoteSlug  String?
  sourceNoteTitle String?

  // Optional: move plans into workspaces later; this lets you start now without breaking legacy
  workspaceId String?
  workspace   Workspace? @relation(fields: [workspaceId], references: [id], onDelete: SetNull)

  @@index([ownerId])
  @@index([workspaceId])
}

model PracticeItem {
  id          Int                 @id @default(autoincrement())
  planId      Int
  plan        PracticePlan        @relation(fields: [planId], references: [id])
  title       String
  category    PracticeCategory
  duration    Int
  description String?
  order       Int
  targetType  PracticeTargetType?
  targetRefId String?

  @@index([planId])
}

model FocusSession {
  id          String @id @default(cuid())
  userId      String
  workspaceId String

  targetId String
  target   PracticeTarget @relation(fields: [targetId], references: [id])

  startedAt   DateTime
  endedAt     DateTime?
  durationSec Int?

  metricType  FocusMetricType
  metricValue Float?

  difficulty FocusDifficulty?
  notes      String?

  createdAt DateTime @default(now())
}

model PracticeTarget {
  id          String @id @default(cuid())
  userId      String
  workspaceId String

  type  PracticeTargetType
  refId String? // nullable for CUSTOM
  title String // snapshot title for history safety

  createdAt     DateTime       @default(now())
  focusSessions FocusSession[]
}

// --------------------
// Workspaces + Members
// --------------------

model Workspace {
  id        String        @id @default(cuid())
  type      WorkspaceType
  name      String
  slug      String        @unique
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  members WorkspaceMember[]

  // Workspace-owned resources (notes/tags are workspace-first)
  notes Note[]
  tags  Tag[]

  // Optional legacy bridge (since Song/PracticePlan have workspaceId?)
  songs               Song[]
  plans               PracticePlan[]
  performanceProjects PerformanceProject[]
  performanceTracks   PerformanceTrack[]
  performanceClips    PerformanceClip[]
  assets              Asset[]
  exportJobs          ExportJob[]

  @@index([type])
}

model WorkspaceMember {
  id          String        @id @default(cuid())
  workspaceId String
  userId      Int
  role        WorkspaceRole @default(MEMBER)

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  joinedAt DateTime @default(now())

  @@unique([workspaceId, userId])
  @@index([userId])
  @@index([workspaceId, role])
}

// --------------------
// Notes (workspace-owned)
// --------------------

model Note {
  id String @id @default(cuid())

  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  // Attribution (optional)
  createdById Int?
  updatedById Int?
  createdBy   User? @relation("NoteCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  updatedBy   User? @relation("NoteUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  title     String
  slug      String
  contentMd String @db.Text

  visibility  Visibility @default(PRIVATE)
  frontmatter Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tags     NoteTag[]
  outgoing NoteLink[]  @relation("OutgoingLinks")
  incoming NoteLink[]  @relation("IncomingLinks")
  blocks   NoteBlock[]

  @@unique([workspaceId, slug])
  @@index([workspaceId, updatedAt])
  @@index([workspaceId, visibility])
}

model Tag {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  name      String
  createdAt DateTime @default(now())

  notes NoteTag[]

  @@unique([workspaceId, name])
  @@index([workspaceId, name])
}

model NoteTag {
  noteId String
  tagId  String

  note Note @relation(fields: [noteId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([noteId, tagId])
  @@index([tagId])
}

model NoteLink {
  id String @id @default(cuid())

  fromNoteId String
  toNoteId   String?

  toSlug String
  alias  String?

  raw     String?
  context String?

  from Note  @relation("OutgoingLinks", fields: [fromNoteId], references: [id], onDelete: Cascade)
  to   Note? @relation("IncomingLinks", fields: [toNoteId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@unique([fromNoteId, toSlug])
  @@index([fromNoteId])
  @@index([toNoteId])
  @@index([toSlug])
}

model NoteBlock {
  id String @id @default(cuid())

  noteId String
  note   Note   @relation(fields: [noteId], references: [id], onDelete: Cascade)

  type  String
  data  Json
  order Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([noteId, type])
}

model PerformanceProject {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  name       String
  bpm        Int
  sampleRate Int

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tracks     PerformanceTrack[]
  clips      PerformanceClip[]
  exportJobs ExportJob[]

  @@index([workspaceId])
}

model PerformanceTrack {
  id          String    @id @default(cuid())
  workspaceId String
  projectId   String

  workspace Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project   PerformanceProject @relation(fields: [projectId], references: [id], onDelete: Cascade)

  index  Int
  name   String
  gainDb Float  @default(0)
  pan    Float  @default(0)
  mute   Boolean @default(false)
  solo   Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clips PerformanceClip[]

  @@unique([projectId, index])
  @@index([workspaceId])
  @@index([projectId])
}

model PerformanceClip {
  id          String    @id @default(cuid())
  workspaceId String
  projectId   String
  trackId     String
  assetId     String

  workspace Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project   PerformanceProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  track     PerformanceTrack   @relation(fields: [trackId], references: [id], onDelete: Cascade)
  asset     Asset              @relation(fields: [assetId], references: [id], onDelete: Restrict)

  startMs         Int
  durationMs      Int
  offsetInAssetMs Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId])
  @@index([projectId])
  @@index([trackId])
  @@index([assetId])
}

model Asset {
  id          String    @id @default(cuid())
  workspaceId String
  workspace   Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  key         String
  bucket      String
  contentType String
  byteSize    Int?
  sha256      String?
  durationMs  Int?
  sampleRate  Int?
  channels    Int?
  status      AssetStatus @default(PENDING_UPLOAD)
  waveformPeaks Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  clips      PerformanceClip[]
  exportJobs ExportJob[] @relation("ExportJobOutput")

  @@unique([workspaceId, key])
  @@index([workspaceId])
  @@index([status])
}

model ExportJob {
  id          String    @id @default(cuid())
  workspaceId String
  projectId   String
  outAssetId  String?

  workspace Workspace          @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  project   PerformanceProject @relation(fields: [projectId], references: [id], onDelete: Cascade)
  outAsset  Asset?             @relation("ExportJobOutput", fields: [outAssetId], references: [id], onDelete: SetNull)

  status ExportJobStatus @default(QUEUED)
  format ExportFormat
  error  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([workspaceId])
  @@index([projectId])
  @@index([status])
}
